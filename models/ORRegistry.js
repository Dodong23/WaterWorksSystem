const mongoose = require('mongoose');
const { Schema } = mongoose;

// Schema for individual OR tracking in orList
const orListItemSchema = new Schema({
    orNumber: {
        type: Number,
        required: true,
        min: 1
    },
    status: {
        type: String,
        enum: ['available', 'issued', 'cancelled'],
        default: 'available'
    },
    paymentID: {
        type: String,
        trim: true,
        default: ''
    },
    issuedAt: {
        type: Date
    },
    issuedTo: {
        type: String,
        trim: true
    },
    cancelledAt: {
        type: Date
    },
    cancelledBy: {
        type: String,
        trim: true
    },
    cancellationReason: {
        type: String,
        trim: true
    },
    notes: {
        type: String,
        trim: true
    },
    _id: false // Don't create _id for subdocuments to reduce overhead
});

// Schema for OR usage tracking (maintained for backward compatibility)
const orUsageSchema = new Schema({
    orNumber: {
        type: String,
        required: true,
        trim: true
    },
    usedBy: {
        type: String,
        required: true,
        trim: true
    },
    userId: {
        type: Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    dateUsed: {
        type: Date,
        required: true,
        default: Date.now
    },
    paymentId: {
        type: Schema.Types.ObjectId,
        ref: 'Payment'
    },
    purpose: {
        type: String,
        trim: true,
        default: 'Payment'
    },
    amount: {
        type: Number,
        min: 0
    },
    remarks: {
        type: String,
        trim: true
    },
    isVoid: {
        type: Boolean,
        default: false
    },
    voidReason: {
        type: String,
        trim: true
    },
    voidDate: {
        type: Date
    },
    voidBy: {
        type: String,
        trim: true
    }
}, {
    timestamps: true,
    _id: true
});

// Main OR Registry Schema
const orRegistrySchema = new Schema({
    // Auto-generated by MongoDB
    // _id: ObjectId

    // Batch Information
    batchCode: {
        type: String,
        required: [true, 'Batch code is required'],
        unique: true,
        trim: true,
        uppercase: true,
        match: [/^[A-Z0-9-]+$/, 'Batch code can only contain letters, numbers, and hyphens']
    },
    
    // OR Number Configuration
    prefix: {
        type: String,
        default: '',
        trim: true,
        maxlength: [10, 'Prefix cannot exceed 10 characters']
    },
    startNumber: {
        type: Number,
        required: [true, 'Start number is required'],
        min: [1, 'Start number must be at least 1'],
        validate: {
            validator: Number.isInteger,
            message: 'Start number must be an integer'
        }
    },
    endNumber: {
        type: Number,
        required: [true, 'End number is required'],
        min: [1, 'End number must be at least 1'],
        validate: [
            {
                validator: Number.isInteger,
                message: 'End number must be an integer'
            },
            {
                validator: function(value) {
                    return value > this.startNumber;
                },
                message: 'End number must be greater than start number'
            }
        ]
    },
    currentNumber: {
        type: Number,
        required: true,
        min: [1, 'Current number must be at least 1'],
        validate: [
            {
                validator: Number.isInteger,
                message: 'Current number must be an integer'
            },
            {
                validator: function(value) {
                    return value >= this.startNumber && value <= this.endNumber + 1;
                },
                message: 'Current number must be within range or one beyond end number'
            }
        ]
    },
    
    // Individual OR Tracking
    orList: [orListItemSchema],
    
    // Status Management
    status: {
        type: String,
        enum: {
            values: ['active', 'inactive', 'pending', 'completed', 'hold'],
            message: 'Status must be one of: active, inactive, pending, completed, hold'
        },
        default: 'pending',
        index: true
    },
    
    // User Assignment
    assignedTo: {
        type: String,
        required: [true, 'Assigned to field is required'],
        trim: true
    },
    assignedUserId: {
        type: String,
        ref: 'User'
    },
    
    // Audit Trail
    entryBy: {
        type: String,
        required: [true, 'Entry by field is required'],
        trim: true
    },
    entryUserId: {
        type: String,
        ref: 'User',
        required: true
    },
    
    // Additional Information
    notes: {
        type: String,
        trim: true,
        maxlength: [500, 'Notes cannot exceed 500 characters']
    },
    
    // Usage Tracking (for backward compatibility)
    usage: [orUsageSchema],
    
    // Auto-generated dates
    dateCreated: {
        type: Date,
        default: Date.now,
        immutable: true
    },
    lastUpdated: {
        type: Date,
        default: Date.now
    },
    dateActivated: {
        type: Date
    },
    dateCompleted: {
        type: Date
    },
    
    // Soft delete
    isDeleted: {
        type: Boolean,
        default: false
    },
    deletedAt: {
        type: Date
    },
    deletedBy: {
        type: String,
        trim: true
    },
    deletedReason: {
        type: String,
        trim: true
    }
}, {
    timestamps: true, // Adds createdAt and updatedAt automatically
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// Virtual properties for easier access
orRegistrySchema.virtual('totalNumbers').get(function() {
    return this.endNumber - this.startNumber + 1;
});

orRegistrySchema.virtual('usedNumbers').get(function() {
    return this.currentNumber - this.startNumber;
});

orRegistrySchema.virtual('availableNumbers').get(function() {
    return Math.max(0, this.endNumber - this.currentNumber + 1);
});

orRegistrySchema.virtual('percentageUsed').get(function() {
    const total = this.totalNumbers;
    const used = this.usedNumbers;
    return total > 0 ? Math.round((used / total) * 100) : 0;
});

orRegistrySchema.virtual('orRange').get(function() {
    return `${this.prefix}${this.startNumber} - ${this.prefix}${this.endNumber}`;
});

orRegistrySchema.virtual('nextORNumber').get(function() {
    if (this.currentNumber > this.endNumber) return null;
    return `${this.prefix}${this.currentNumber}`;
});

orRegistrySchema.virtual('isExhausted').get(function() {
    return this.currentNumber > this.endNumber;
});

orRegistrySchema.virtual('formattedBatchCode').get(function() {
    return this.batchCode.replace(/-/g, ' ').toUpperCase();
});

// New virtuals for orList tracking
orRegistrySchema.virtual('issuedORs').get(function() {
    if (!this.orList || !this.orList.length) return [];
    return this.orList.filter(item => item.status === 'issued');
});

orRegistrySchema.virtual('availableORs').get(function() {
    if (!this.orList || !this.orList.length) return [];
    return this.orList.filter(item => item.status === 'available');
});

orRegistrySchema.virtual('cancelledORs').get(function() {
    if (!this.orList || !this.orList.length) return [];
    return this.orList.filter(item => item.status === 'cancelled');
});

orRegistrySchema.virtual('orListStats').get(function() {
    if (!this.orList || !this.orList.length) {
        return {
            total: 0,
            available: 0,
            issued: 0,
            cancelled: 0,
            voided: 0,
            reserved: 0
        };
    }
    
    return {
        total: this.orList.length,
        available: this.orList.filter(item => item.status === 'available').length,
        issued: this.orList.filter(item => item.status === 'issued').length,
        cancelled: this.orList.filter(item => item.status === 'cancelled').length,
        voided: this.orList.filter(item => item.status === 'voided').length,
        reserved: this.orList.filter(item => item.status === 'reserved').length
    };
});

// Indexes for better query performance
// Note: `batchCode` already defines `unique: true` at the field level;
// avoid duplicating the index declaration to prevent Mongoose warnings.
orRegistrySchema.index({ status: 1, assignedTo: 1 });
orRegistrySchema.index({ 'usage.orNumber': 1 });
orRegistrySchema.index({ startNumber: 1, endNumber: 1 });
orRegistrySchema.index({ entryUserId: 1, dateCreated: -1 });
orRegistrySchema.index({ assignedUserId: 1, status: 1 });
orRegistrySchema.index({ isDeleted: 1 });
orRegistrySchema.index({ 'orList.status': 1 }); // Index for orList status queries
orRegistrySchema.index({ 'orList.paymentID': 1 }); // Index for payment lookups

// Middleware hooks
orRegistrySchema.pre('save', function(next) {
    // Update lastUpdated timestamp
    this.lastUpdated = new Date();
    
    // Update dateActivated if status changes to active
    if (this.isModified('status') && this.status === 'active' && !this.dateActivated) {
        this.dateActivated = new Date();
    }
    
    // Update dateCompleted if status changes to completed
    if (this.isModified('status') && this.status === 'completed' && !this.dateCompleted) {
        this.dateCompleted = new Date();
    }
    
    // Initialize orList if it doesn't exist
    if (!this.orList || this.orList.length === 0) {
        this.initializeORList();
    }
    
    next();
});

// Initialize orList with default values
orRegistrySchema.methods.initializeORList = function() {
    this.orList = [];
    for (let i = this.startNumber; i <= this.endNumber; i++) {
        this.orList.push({
            orNumber: i,
            status: 'available',
            paymentID: ''
        });
    }
};

orRegistrySchema.pre('find', function() {
    this.where({ isDeleted: { $ne: true } });
});

orRegistrySchema.pre('findOne', function() {
    this.where({ isDeleted: { $ne: true } });
});

// Static methods
orRegistrySchema.statics.findByBatchCode = function(batchCode) {
    return this.findOne({ batchCode: batchCode.toUpperCase() });
};

orRegistrySchema.statics.findActiveBatches = function() {
    return this.find({ status: 'active', isDeleted: false })
        .sort({ currentNumber: 1 });
};

orRegistrySchema.statics.findByAssignedUser = function(userId) {
    return this.find({ 
        assignedUserId: userId, 
        status: { $in: ['active', 'pending'] },
        isDeleted: false 
    });
};

orRegistrySchema.statics.getAvailableBatches = function() {
    return this.find({ 
        status: 'active',
        currentNumber: { $lte: this.endNumber },
        isDeleted: false 
    }).select('batchCode prefix currentNumber endNumber assignedTo');
};

// Instance methods
orRegistrySchema.methods.issueNextOR = function(usageData) {
    if (this.currentNumber > this.endNumber) {
        throw new Error('No more OR numbers available in this batch');
    }
    
    if (this.status !== 'active') {
        throw new Error(`Cannot issue OR from ${this.status} batch`);
    }
    
    const orNumber = `${this.prefix}${this.currentNumber}`;
    
    // Find the OR in orList and update it
    const orItem = this.orList.find(item => item.orNumber === this.currentNumber);
    if (orItem) {
        orItem.status = 'issued';
        orItem.paymentID = usageData.paymentID || '';
        orItem.issuedAt = new Date();
        orItem.issuedTo = usageData.issuedTo || usageData.usedBy || 'System';
        orItem.notes = usageData.remarks || '';
    }
    
    // Create usage record (for backward compatibility)
    const usageRecord = {
        orNumber: orNumber,
        usedBy: usageData.usedBy,
        userId: usageData.userId,
        paymentId: usageData.paymentId,
        purpose: usageData.purpose || 'Payment',
        amount: usageData.amount,
        remarks: usageData.remarks
    };
    
    // Add to usage array
    this.usage.push(usageRecord);
    
    // Increment current number
    this.currentNumber++;
    
    // Update status to completed if exhausted
    if (this.currentNumber > this.endNumber) {
        this.status = 'completed';
    }
    
    return {
        orNumber: orNumber,
        usageRecord: usageRecord,
        orItem: orItem,
        batch: this.batchCode,
        nextAvailable: this.nextORNumber
    };
};

// New method to issue specific OR number
orRegistrySchema.methods.issueSpecificOR = function(orNumber, usageData) {
    const numericOR = parseInt(orNumber.replace(this.prefix, ''));
    
    const orItem = this.orList.find(item => item.orNumber === numericOR);
    if (!orItem) {
        throw new Error(`OR number ${orNumber} not found in this batch`);
    }
    
    if (orItem.status !== 'available') {
        throw new Error(`OR number ${orNumber} is already ${orItem.status}`);
    }
    
    orItem.status = 'issued';
    orItem.paymentID = usageData.paymentID || '';
    orItem.issuedAt = new Date();
    orItem.issuedTo = usageData.issuedTo || usageData.usedBy || 'System';
    orItem.notes = usageData.remarks || '';
    
    // Update currentNumber if this is the next in sequence
    if (numericOR === this.currentNumber) {
        this.currentNumber++;
        
        // Update status to completed if exhausted
        if (this.currentNumber > this.endNumber) {
            this.status = 'completed';
        }
    }
    
    return orItem;
};

// Cancel an OR
orRegistrySchema.methods.cancelOR = function(orNumber, cancelData) {
    const numericOR = parseInt(orNumber.replace(this.prefix, ''));
    
    const orItem = this.orList.find(item => item.orNumber === numericOR);
    if (!orItem) {
        throw new Error(`OR number ${orNumber} not found in this batch`);
    }
    
    if (orItem.status !== 'issued') {
        throw new Error(`OR number ${orNumber} is not issued (current status: ${orItem.status})`);
    }
    
    orItem.status = 'cancelled';
    orItem.cancelledAt = new Date();
    orItem.cancelledBy = cancelData.cancelledBy || 'System';
    orItem.cancellationReason = cancelData.reason || '';
    
    return orItem;
};

// Get available OR from orList
orRegistrySchema.methods.getNextAvailableOR = function() {
    const availableOR = this.orList.find(item => item.status === 'available');
    if (!availableOR) return null;
    
    return {
        orNumber: `${this.prefix}${availableOR.orNumber}`,
        numericOR: availableOR.orNumber,
        status: availableOR.status
    };
};

// Get OR by number
orRegistrySchema.methods.getORByNumber = function(orNumber) {
    const numericOR = parseInt(orNumber.replace(this.prefix, ''));
    return this.orList.find(item => item.orNumber === numericOR);
};

// Get all ORs with a specific status
orRegistrySchema.methods.getORsByStatus = function(status) {
    return this.orList.filter(item => item.status === status);
};

orRegistrySchema.methods.voidOR = function(orNumber, voidData) {
    const usageRecord = this.usage.find(record => record.orNumber === orNumber);
    
    if (!usageRecord) {
        throw new Error(`OR number ${orNumber} not found in this batch`);
    }
    
    if (usageRecord.isVoid) {
        throw new Error(`OR number ${orNumber} is already voided`);
    }
    
    usageRecord.isVoid = true;
    usageRecord.voidReason = voidData.reason;
    usageRecord.voidDate = new Date();
    usageRecord.voidBy = voidData.voidBy;
    
    // Also update orList if this OR exists there
    const numericOR = parseInt(orNumber.replace(this.prefix, ''));
    const orItem = this.orList.find(item => item.orNumber === numericOR);
    if (orItem) {
        orItem.status = 'voided';
    }
    
    return usageRecord;
};

orRegistrySchema.methods.getUsageStats = function() {
    const totalIssued = this.usedNumbers;
    const voided = this.usage.filter(record => record.isVoid).length;
    const active = totalIssued - voided;
    
    return {
        totalIssued: totalIssued,
        voided: voided,
        active: active,
        available: this.availableNumbers,
        percentageUsed: this.percentageUsed,
        lastUsed: this.usage.length > 0 
            ? this.usage[this.usage.length - 1].dateUsed 
            : null,
        orListStats: this.orListStats
    };
};

// Validation middleware for batch code uniqueness
orRegistrySchema.post('save', function(error, doc, next) {
    if (error.name === 'MongoError' && error.code === 11000) {
        next(new Error('Batch code already exists'));
    } else {
        next(error);
    }
});

// Create and export the model
const ORRegistry = mongoose.model('ORRegistry', orRegistrySchema);

module.exports = ORRegistry;